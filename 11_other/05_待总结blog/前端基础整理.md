# 前端基础整理

注意，知识是一点，还要举一反三，想到业务场景。

## 截流防抖

### 简单防抖（debounce）

要知道应用了闭包，这个很关键

```js
function debounce(func, delay) {
  let timeID;
  return function() {
    const context = this;
    const args = [...arguments];

    clearTimeout(timeID)

    timeID = setTimeout(() => {
      func.apply(context, args);
    }, delay)
  }
}
```

```js
const debounce = (func, delay) => {
  let timeID;
  // 这里能用箭头函数吗？
  return () => {
    const context = this;
    const args = arguments;

    // 规定时间内再次触发先清除定时器再设置定时器
    clearTimeout(timeID);

    timeID = setTimeout(() => {
      func.apply(context, args);
    }, delay)
  }
}
```

### 简单截流（throttle）

```js
function throttle(func, delay) {
  let wait = false;
  return function() {
    let ctx = this;
    let args = [...arguments];

    if (!wait) {
      wait = true;
      setTimeout(() => {
        // function 也可以拿到 setTimeout 外面，看是否立即执行
        func.apply(this, args);
        wait = false;
      }, delay)
    }
  }
}
```
上面的写法有问题，如果是多个函数需要使用 throttle 进行处理，他们会共同访问 `wait`，会出现混乱。使用时间戳比较好

```js
function throttle(fn, delay) {
  let prev = Date.now();

  return function(...args) {
    let ctx = this;
    let curr = Date.now();

    if (curr - pre > delay) {
      // 这里可以写到外面就可以立即执行
      fn.apply(ctx, args);
      prev = Date.now();
    }
  }
}
```

```js
const throttle = (func, delay) => {
  let prev = Date.now();
  return () => {
    const arg = arguments;
    const context = this;

    const curr = Date.now();
    if (curr - prev > delay) {
      func.apply(context, args);

      // 执行完一次重新赋值 prev
      prev = Date.now();
    }
  }
}
```

## bind 函数

```js
Function.prototype.myBind = function(ctx) {
  return function() {
    this.apply(ctx, [...arguments])
  }
}

```
## 常见排序，搜索算法

## 常见设计模式

## 取消请求（自己封装fetch）及应用

## 获取页面宽高，距离顶部高度等

## 手机判断及开发常见问题

## rem 布局方法

## http 常见知识点

## 缓存相关

## 图片优化

## 常列表加载优化

throttle，分批渲染 vue 等

## css 常见布局

## href src 区别

## 数据常见函数及易错点

## 原型继承

## 前端路由

## webpack 相关

插件原理

## babel 相关

插件

## vue 应用及常见考点

## react 应用及常见考点

部分函数源码， setState， shouldUpdated，高阶组件

## 前端路由原理

## 服务端渲染

## 跨域相关

## 安全相关

## gulp webapck 区别

I find these answers so far to be confusing.

They are different tools that can be used separately to do the same thing, or can be used together to do complementary things.

Webpack is a **module bundler**. It allows you to use the NodeJS require() and module.exports syntax (or ES2015 modules, with Babel) to organize your front end code in separate files with functionality that can be imported between them as needed.

Webpack can also include plugins that will do things like minify code, and through the use of loaders it can also bundle/transform fonts, SCSS, ES2015 JS, JSX, etc as necessary. But this is all on top of its basic function as a bundler. In its most basic configuration, all of the files you put into Webpack including CSS will come out in a single .js bundle that you can put in your site. This can be changed, though.

Gulp is a **task runner**. It is basically a convenient way of automating various tasks that may need to happen in your build/deploy process, similar to a Makefile or writing shell scripts yourself.

Gulp can be used to do what Webpack does. If you run browserify in a gulp task, it also lets you use modules. Otherwise you can have a gulp task that simply concatenates a bunch of JS files together into one, which is similar but you will still be writing modules that are added to the global namespace of your website, rather than using require or ES2015 import/export.

Gulp is more general. I have written gulp tasks to package and deploy projects to Elastic Beanstalk, for example.

I think Webpack is a superior tool strictly for bundling web apps, since it gives you module syntax without configuring one more tool and allows for some cool optimizations like code splitting.

Basically I like to use Webpack as the primary build tool but have it driven by gulp or npm scripts depending on how complicated OTHER aspects of building/deploying the project are. Gulp is very nice to use compared to Grunt or writing shell scripts, and there are times when it is necessary, but IMO it isn't as good as Webpack for just putting your code together.



